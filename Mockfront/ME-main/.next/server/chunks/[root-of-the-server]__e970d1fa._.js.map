{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/ME/app/api/_lib/db.mjs"],"sourcesContent":["// src/app/api/_lib/db.mjs\r\nimport { Pool } from \"pg\";\r\n\r\nlet _pool = globalThis.__PG_POOL;\r\nif (!_pool) {\r\n  _pool = new Pool({\r\n    connectionString: process.env.DATABASE_URL,\r\n    ssl: { rejectUnauthorized: false }, // Neon\r\n  });\r\n  globalThis.__PG_POOL = _pool;\r\n}\r\n\r\nexport function getPool() {\r\n  return _pool;\r\n}\r\n\r\n/**\r\n * withClient(async (c) => { ... })  // c = client PG\r\n * Gère connect/release et laisse ton code au propre.\r\n */\r\nexport async function withClient(fn) {\r\n  const pool = getPool();\r\n  const client = await pool.connect();\r\n  try {\r\n    return await fn(client);\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;AAC1B;;;;;;AAEA,IAAI,QAAQ,WAAW,SAAS;AAChC,IAAI,CAAC,OAAO;IACV,QAAQ,IAAI,oGAAA,CAAA,OAAI,CAAC;QACf,kBAAkB,QAAQ,GAAG,CAAC,YAAY;QAC1C,KAAK;YAAE,oBAAoB;QAAM;IACnC;IACA,WAAW,SAAS,GAAG;AACzB;AAEO,SAAS;IACd,OAAO;AACT;AAMO,eAAe,WAAW,EAAE;IACjC,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,OAAO,MAAM,GAAG;IAClB,SAAU;QACR,OAAO,OAAO;IAChB;AACF","debugId":null}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/ME/app/api/_lib/kickSLA.ts"],"sourcesContent":["// app/api/_lib/kickSLA.ts\r\nimport { getPool } from \"./db.mjs\";\r\n\r\n// Throttle: 1 exécution max toutes les 2 minutes par instance\r\nlet lastRun = 0;\r\nconst MIN_MS_BETWEEN_RUNS = 2 * 60 * 1000;\r\n\r\nexport async function kickSLA(limit: number = 200) {\r\n  const now = Date.now();\r\n  if (now - lastRun < MIN_MS_BETWEEN_RUNS) return;\r\n  lastRun = now;\r\n\r\n  try {\r\n    const pool = getPool();\r\n    await pool.query(\"SELECT * FROM core.create_due_tickets($1);\", [limit]);\r\n    await pool.query(\"SELECT core.produce_notifications();\");      // enqueuer selon l'état\r\n    await pool.query(\"SELECT core.dispatch_due_notifications();\"); // envoyer celles arrivées à échéance\r\n  } catch (e: any) {\r\n    console.warn(\"[kickSLA] skipped:\", e.message);\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;AAC1B;;;;;;AAEA,8DAA8D;AAC9D,IAAI,UAAU;AACd,MAAM,sBAAsB,IAAI,KAAK;AAE9B,eAAe,QAAQ,QAAgB,GAAG;IAC/C,MAAM,MAAM,KAAK,GAAG;IACpB,IAAI,MAAM,UAAU,qBAAqB;IACzC,UAAU;IAEV,IAAI;QACF,MAAM,OAAO,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD;QACnB,MAAM,KAAK,KAAK,CAAC,8CAA8C;YAAC;SAAM;QACtE,MAAM,KAAK,KAAK,CAAC,yCAA8C,wBAAwB;QACvF,MAAM,KAAK,KAAK,CAAC,8CAA8C,qCAAqC;IACtG,EAAE,OAAO,GAAQ;QACf,QAAQ,IAAI,CAAC,sBAAsB,EAAE,OAAO;IAC9C;AACF","debugId":null}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/ME/app/api/dashboard/route.js"],"sourcesContent":["// app/api/dashboard/route.ts\r\nexport const runtime = \"nodejs\"; \r\nimport { NextResponse } from \"next/server\";\r\nimport { getPool } from \"../_lib/db.mjs\";\r\nimport { kickSLA } from \"../_lib/kickSLA\";\r\n\r\nconst pool = getPool();\r\n\r\n// helpers\r\nfunction toDateUTC(d) { return d instanceof Date ? d.toISOString().slice(0,10) : d; }\r\n\r\n\r\nexport async function GET(req) {\r\n  await kickSLA();\r\n\r\n  const { searchParams } = new URL(req.url);\r\n  const status      = searchParams.get(\"status\");          // ex: en_cours\r\n  const partnerId   = searchParams.get(\"partnerId\");       // ex: 1\r\n  const operatorId  = searchParams.get(\"operatorId\");      // ex: 2\r\n  const from        = searchParams.get(\"from\");            // ex: 2025-07-01\r\n  const to          = searchParams.get(\"to\");              // ex: 2025-08-31\r\n\r\n  const c = await pool.connect();\r\n  try {\r\n    // ---- dossiers (avec filtres)\r\n    const where = [];\r\n    const args  = [];\r\n    let i = 1;\r\n\r\n    if (status && status !== \"all\")      { where.push(`d.statut = $${i++}`); args.push(status); }\r\n    if (partnerId && partnerId !== \"all\"){ where.push(`d.partenaire_id = $${i++}`); args.push(Number(partnerId)); }\r\n    if (operatorId && operatorId !== \"all\"){ where.push(`d.operateur_id = $${i++}`); args.push(Number(operatorId)); }\r\n    if (from)                            { where.push(`d.date_creation >= $${i++}`); args.push(from); }\r\n    if (to)                              { where.push(`d.date_creation <= $${i++}`); args.push(to); }\r\n\r\n    const whereSql = where.length ? `WHERE ${where.join(\" AND \")}` : \"\";\r\n\r\n    const { rows: dossiers } = await c.query(\r\n      `SELECT\r\n         d.id,\r\n         d.statut,\r\n         d.client_id       AS \"clientId\",\r\n         d.entreprise_id   AS \"entrepriseId\",\r\n         d.partenaire_id   AS \"partenaireId\",\r\n         d.operateur_id    AS \"operateurId\",\r\n         d.date_creation   AS \"date_creation\",\r\n         d.derniere_modification AS \"derniere_modification\",\r\n         d.blocages,\r\n         d.commission_partenaire_eur AS \"commission_partenaire_eur\"\r\n       FROM core.dossiers d\r\n       ${whereSql}\r\n       ORDER BY d.date_creation DESC`\r\n      , args\r\n    );\r\n\r\n    // ---- listes mini pour afficher les noms dans le dashboard\r\n    const { rows: partenaires } = await c.query(\r\n      `SELECT id, nom FROM core.partenaires ORDER BY nom`\r\n    );\r\n    const { rows: operateurs } = await c.query(\r\n      `SELECT id, nom FROM core.operateurs ORDER BY nom`\r\n    );\r\n    const { rows: clients } = await c.query(\r\n      `SELECT id, prenom, nom, email FROM core.clients ORDER BY id`\r\n    );\r\n\r\n    // ---- notifications programmées\r\n    // ---- notifications programmées\r\n// ---- notifications (programmées + déjà envoyées)\r\nconst { rows: notifications } = await c.query(`\r\nWITH q AS (\r\n  SELECT \r\n    id,\r\n    type,\r\n    client_id   AS \"clientId\",\r\n    dossier_id  AS \"dossierId\",\r\n    canal,\r\n    scheduled_for,\r\n    message,\r\n    'queued'::text AS status\r\n  FROM core.notifications_queue\r\n),\r\nsent AS (\r\n  SELECT \r\n    ('sent-'||ea.id)::text      AS id,\r\n    ea.type,\r\n    ea.client_id                AS \"clientId\",\r\n    ea.dossier_id               AS \"dossierId\",\r\n    ea.canal,\r\n    ea.envoye_le                AS scheduled_for,  -- on garde le même nom pour le front\r\n    (\r\n      SELECT note\r\n      FROM core.client_contact_logs cl\r\n      WHERE cl.client_id = ea.client_id\r\n        AND cl.at BETWEEN ea.envoye_le - interval '5 minutes' AND ea.envoye_le + interval '5 minutes'\r\n      ORDER BY cl.at DESC\r\n      LIMIT 1\r\n    )                           AS message,\r\n    'sent'::text                AS status\r\n  FROM core.emails_automatiques ea\r\n  WHERE ea.type LIKE 'notif.%'\r\n)\r\nSELECT * FROM q\r\nUNION ALL\r\nSELECT * FROM sent\r\nORDER BY scheduled_for DESC\r\nLIMIT 200\r\n`);\r\n\r\n\r\n    // ---- derniers auth logs\r\n    const { rows: auth_logs } = await c.query(\r\n      `SELECT at, role, who, action, success, ip\r\n         FROM core.auth_logs\r\n        ORDER BY at DESC\r\n        LIMIT 50`\r\n    );\r\n\r\n    // ---- refs (hardcodé côté API pour le moment)\r\n    const refs = {\r\n      statuts_dossier: [\"nouveau\",\"en_cours\",\"en_attente\",\"a_corriger\",\"valide\",\"rejete\"]\r\n    };\r\n\r\n    return NextResponse.json({\r\n      refs,\r\n      partenaires,\r\n      operateurs,\r\n      clients,\r\n      dossiers: dossiers.map(d => ({\r\n        ...d,\r\n        date_creation: toDateUTC(d.date_creation),\r\n        derniere_modification: toDateUTC(d.derniere_modification),\r\n      })),\r\n      notifications_queue: notifications,\r\n      auth_logs,\r\n    });\r\n  } finally {\r\n    c.release();\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}