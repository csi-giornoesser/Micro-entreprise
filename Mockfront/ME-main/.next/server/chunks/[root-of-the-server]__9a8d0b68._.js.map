{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/ME/app/api/_lib/db.mjs"],"sourcesContent":["// src/app/api/_lib/db.mjs\r\nimport { Pool } from \"pg\";\r\n\r\nlet _pool = globalThis.__PG_POOL;\r\nif (!_pool) {\r\n  _pool = new Pool({\r\n    connectionString: process.env.DATABASE_URL,\r\n    ssl: { rejectUnauthorized: false }, // Neon\r\n  });\r\n  globalThis.__PG_POOL = _pool;\r\n}\r\n\r\nexport function getPool() {\r\n  return _pool;\r\n}\r\n\r\n/**\r\n * withClient(async (c) => { ... })  // c = client PG\r\n * Gère connect/release et laisse ton code au propre.\r\n */\r\nexport async function withClient(fn) {\r\n  const pool = getPool();\r\n  const client = await pool.connect();\r\n  try {\r\n    return await fn(client);\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;AAC1B;;;;;;AAEA,IAAI,QAAQ,WAAW,SAAS;AAChC,IAAI,CAAC,OAAO;IACV,QAAQ,IAAI,oGAAA,CAAA,OAAI,CAAC;QACf,kBAAkB,QAAQ,GAAG,CAAC,YAAY;QAC1C,KAAK;YAAE,oBAAoB;QAAM;IACnC;IACA,WAAW,SAAS,GAAG;AACzB;AAEO,SAAS;IACd,OAAO;AACT;AAMO,eAAe,WAAW,EAAE;IACjC,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,OAAO,MAAM,GAAG;IAClB,SAAU;QACR,OAAO,OAAO;IAChB;AACF","debugId":null}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/ME/app/api/commercial/rappels/route.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { getPool } from \"../../_lib/db.mjs\";\r\n\r\nconst pool = getPool();\r\n\r\nexport async function GET(req) {\r\n  try {\r\n    const c = await pool.connect();\r\n    \r\n    try {\r\n      // Récupérer tous les rappels en attente\r\n      const { rows: rappels } = await c.query(`\r\n        SELECT \r\n          pi.id,\r\n          pi.partner_id,\r\n          pi.date_interaction,\r\n          pi.type_interaction,\r\n          pi.sujet,\r\n          pi.notes,\r\n          pi.prochaine_action,\r\n          pi.rappel_date,\r\n          pi.created_by,\r\n          p.nom as partner_nom\r\n        FROM core.partner_interactions pi\r\n        LEFT JOIN core.partenaires p ON pi.partner_id = p.id\r\n        WHERE pi.prochaine_action IS NOT NULL \r\n          AND pi.statut != 'termine'\r\n        ORDER BY \r\n          CASE \r\n            WHEN pi.rappel_date IS NULL THEN 1\r\n            WHEN pi.rappel_date < CURRENT_DATE THEN 0  -- En retard en premier\r\n            ELSE 2\r\n          END,\r\n          pi.rappel_date ASC,\r\n          pi.date_interaction DESC\r\n      `);\r\n\r\n      // Calculer les stats\r\n      const today = new Date();\r\n      const stats = {\r\n        total: rappels.length,\r\n        en_retard: 0,\r\n        aujourd_hui: 0,\r\n        cette_semaine: 0,\r\n        plus_tard: 0\r\n      };\r\n\r\n      rappels.forEach(rappel => {\r\n        if (!rappel.rappel_date) {\r\n          stats.plus_tard++;\r\n          return;\r\n        }\r\n\r\n        const rappelDate = new Date(rappel.rappel_date);\r\n        const diffDays = Math.ceil((rappelDate - today) / (1000 * 60 * 60 * 24));\r\n\r\n        if (diffDays < 0) {\r\n          stats.en_retard++;\r\n        } else if (diffDays === 0) {\r\n          stats.aujourd_hui++;\r\n        } else if (diffDays <= 7) {\r\n          stats.cette_semaine++;\r\n        } else {\r\n          stats.plus_tard++;\r\n        }\r\n      });\r\n\r\n      // Récupérer aussi quelques métriques globales\r\n      const { rows: globalStats } = await c.query(`\r\n        SELECT \r\n          COUNT(DISTINCT pi.partner_id) as partenaires_actifs,\r\n          COUNT(*) as total_interactions_mois,\r\n          COUNT(CASE WHEN pi.type_interaction = 'reunion' THEN 1 END) as reunions_mois\r\n        FROM core.partner_interactions pi\r\n        WHERE pi.date_interaction >= DATE_TRUNC('month', CURRENT_DATE)\r\n      `);\r\n\r\n      return NextResponse.json({\r\n        rappels,\r\n        stats,\r\n        global_stats: globalStats[0] || {},\r\n        generated_at: new Date().toISOString()\r\n      });\r\n\r\n    } finally {\r\n      c.release();\r\n    }\r\n\r\n  } catch (e) {\r\n    console.error(\"Erreur API rappels commerciaux:\", e);\r\n    return NextResponse.json({\r\n      error: \"Erreur lors de la récupération des rappels\"\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n// POST - Marquer une action comme terminée\r\nexport async function POST(req) {\r\n  try {\r\n    const body = await req.json().catch(() => ({}));\r\n    const { interaction_id, action = 'termine' } = body;\r\n\r\n    if (!interaction_id) {\r\n      return NextResponse.json({ error: \"interaction_id requis\" }, { status: 400 });\r\n    }\r\n\r\n    const c = await pool.connect();\r\n    \r\n    try {\r\n      await c.query(\"BEGIN\");\r\n\r\n      // Marquer l'interaction comme terminée\r\n      const { rows: updated } = await c.query(`\r\n        UPDATE core.partner_interactions \r\n        SET statut = $1\r\n        WHERE id = $2\r\n        RETURNING id, partner_id, sujet, prochaine_action\r\n      `, [action, parseInt(interaction_id)]);\r\n\r\n      if (!updated.length) {\r\n        await c.query(\"ROLLBACK\");\r\n        return NextResponse.json({ error: \"Interaction introuvable\" }, { status: 404 });\r\n      }\r\n\r\n      await c.query(\"COMMIT\");\r\n\r\n      return NextResponse.json({\r\n        interaction: updated[0],\r\n        message: \"Action marquée comme terminée\"\r\n      });\r\n\r\n    } finally {\r\n      c.release();\r\n    }\r\n\r\n  } catch (e) {\r\n    console.error(\"Erreur POST rappel commercial:\", e);\r\n    return NextResponse.json({\r\n      error: \"Erreur lors de la mise à jour\"\r\n    }, { status: 500 });\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,MAAM,OAAO,CAAA,GAAA,2HAAA,CAAA,UAAO,AAAD;AAEZ,eAAe,IAAI,GAAG;IAC3B,IAAI;QACF,MAAM,IAAI,MAAM,KAAK,OAAO;QAE5B,IAAI;YACF,wCAAwC;YACxC,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,EAAE,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;MAwBzC,CAAC;YAED,qBAAqB;YACrB,MAAM,QAAQ,IAAI;YAClB,MAAM,QAAQ;gBACZ,OAAO,QAAQ,MAAM;gBACrB,WAAW;gBACX,aAAa;gBACb,eAAe;gBACf,WAAW;YACb;YAEA,QAAQ,OAAO,CAAC,CAAA;gBACd,IAAI,CAAC,OAAO,WAAW,EAAE;oBACvB,MAAM,SAAS;oBACf;gBACF;gBAEA,MAAM,aAAa,IAAI,KAAK,OAAO,WAAW;gBAC9C,MAAM,WAAW,KAAK,IAAI,CAAC,CAAC,aAAa,KAAK,IAAI,CAAC,OAAO,KAAK,KAAK,EAAE;gBAEtE,IAAI,WAAW,GAAG;oBAChB,MAAM,SAAS;gBACjB,OAAO,IAAI,aAAa,GAAG;oBACzB,MAAM,WAAW;gBACnB,OAAO,IAAI,YAAY,GAAG;oBACxB,MAAM,aAAa;gBACrB,OAAO;oBACL,MAAM,SAAS;gBACjB;YACF;YAEA,8CAA8C;YAC9C,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,EAAE,KAAK,CAAC,CAAC;;;;;;;MAO7C,CAAC;YAED,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB;gBACA;gBACA,cAAc,WAAW,CAAC,EAAE,IAAI,CAAC;gBACjC,cAAc,IAAI,OAAO,WAAW;YACtC;QAEF,SAAU;YACR,EAAE,OAAO;QACX;IAEF,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,OAAO;QACT,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF;AAGO,eAAe,KAAK,GAAG;IAC5B,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,EAAE,cAAc,EAAE,SAAS,SAAS,EAAE,GAAG;QAE/C,IAAI,CAAC,gBAAgB;YACnB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAwB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,MAAM,IAAI,MAAM,KAAK,OAAO;QAE5B,IAAI;YACF,MAAM,EAAE,KAAK,CAAC;YAEd,uCAAuC;YACvC,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,EAAE,KAAK,CAAC,CAAC;;;;;MAKzC,CAAC,EAAE;gBAAC;gBAAQ,SAAS;aAAgB;YAErC,IAAI,CAAC,QAAQ,MAAM,EAAE;gBACnB,MAAM,EAAE,KAAK,CAAC;gBACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAA0B,GAAG;oBAAE,QAAQ;gBAAI;YAC/E;YAEA,MAAM,EAAE,KAAK,CAAC;YAEd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB,aAAa,OAAO,CAAC,EAAE;gBACvB,SAAS;YACX;QAEF,SAAU;YACR,EAAE,OAAO;QACX;IAEF,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,OAAO;QACT,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF","debugId":null}}]
}