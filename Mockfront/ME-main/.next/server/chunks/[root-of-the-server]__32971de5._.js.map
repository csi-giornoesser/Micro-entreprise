{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/giorn/Desktop/Projet/Medina/Micro_entreprise/Mockfront/ME-main/app/api/_lib/proxy.ts"],"sourcesContent":["// app/api/_lib/proxy.ts\n/**\n * Proxy helper pour relayer une requête Next.js vers l'API Express.\n * - récupère la base URL depuis API_INTERNAL_URL ou NEXT_PUBLIC_API_URL\n * - fusionne les query params entrants\n * - propage headers/cookies (en nettoyant ceux interdits)\n * - retourne la réponse (stream) telle quelle\n */\n\nfunction getApiBase(): string {\n  // On essaie d’abord API_INTERNAL_URL (backend privé), puis NEXT_PUBLIC_API_URL (public)\n  const base =\n    process.env.API_INTERNAL_URL ||\n    process.env.NEXT_PUBLIC_API_URL ||\n    \"\";\n\n  if (!base) {\n    throw new Error(\n      \"API_INTERNAL_URL (ou NEXT_PUBLIC_API_URL) manquant dans l'environnement\"\n    );\n  }\n\n  // Valide et normalise\n  let u: URL;\n  try {\n    // Supporte base avec ou sans trailing slash\n    u = new URL(base.startsWith(\"http\") ? base : `http://${base}`);\n  } catch {\n    throw new Error(`API base URL invalide: \"${base}\"`);\n  }\n  return u.toString().replace(/\\/+$/, \"\"); // retire trailing slash\n}\n\nfunction mergeQuery(to: URL, from: URL) {\n  // on garde ce qui est déjà dans \"to\" et on ajoute/écrase avec ceux de \"from\"\n  from.searchParams.forEach((v, k) => {\n    if (!to.searchParams.has(k)) to.searchParams.set(k, v);\n  });\n}\n\nfunction passthroughRequestHeaders(req: Request, extra?: HeadersInit): Headers {\n  const out = new Headers(extra || undefined);\n\n  // Copie les headers utiles (cookies, auth, content-type…)\n  for (const [k, v] of req.headers) {\n    const key = k.toLowerCase();\n    // headers interdits à setter côté fetch\n    if ([\"host\", \"content-length\", \"connection\"].includes(key)) continue;\n    if (!out.has(k)) out.set(k, v);\n  }\n\n  return out;\n}\n\nfunction passthroughResponseHeaders(h: Headers): Headers {\n  const out = new Headers();\n  for (const [k, v] of h) {\n    const key = k.toLowerCase();\n    // on peut filtrer certains hop-by-hop si besoin\n    if ([\"transfer-encoding\", \"connection\"].includes(key)) continue;\n    out.set(k, v);\n  }\n  return out;\n}\n\n/**\n * Proxy principal\n * @param req  requête entrante (Next route handler)\n * @param path chemin à appeler côté API (ex: \"/api/alerts\" ou `/api/clients/${id}`)\n * @param init overrides (method/body/headers…) si besoin\n */\nexport async function proxyRequest(\n  req: Request,\n  path: string,\n  init?: RequestInit\n): Promise<Response> {\n  const base = getApiBase();\n\n  // Construit l’URL cible\n  // - path peut contenir un querystring propre\n  const target = new URL(\n    path.startsWith(\"/\") ? `${base}${path}` : `${base}/${path}`\n  );\n\n  // Fusionne les query params de la requête entrante\n  const incoming = new URL(req.url);\n  mergeQuery(target, incoming);\n\n  // Méthode & body\n  const method = (init?.method || req.method || \"GET\").toUpperCase();\n\n  // Body : uniquement si non GET/HEAD\n  let body: BodyInit | undefined = init?.body;\n  if (!body && method !== \"GET\" && method !== \"HEAD\") {\n    // on lit le body une seule fois (arrayBuffer pour supporter tout type)\n    const ab = await req.arrayBuffer().catch(() => null);\n    if (ab) body = ab;\n  }\n\n  // Headers (on propage + extra éventuels)\n  const headers = passthroughRequestHeaders(req, init?.headers);\n\n  // Appel API\n  const resp = await fetch(target.toString(), {\n    method,\n    headers,\n    body,\n    // important pour laisser passer les redirects/API brutes\n    redirect: \"manual\",\n    // credentials: \"include\" // inutile ici, on propage déjà Cookie\n  });\n\n  // On renvoie le stream tel quel, avec headers nettoyés\n  return new Response(resp.body, {\n    status: resp.status,\n    statusText: resp.statusText,\n    headers: passthroughResponseHeaders(resp.headers),\n  });\n}\n\n/* ------- Helpers pratiques (optionnel) ------- */\n\nexport const proxyGET = (req: Request, path: string) =>\n  proxyRequest(req, path, { method: \"GET\" });\n\nexport const proxyPOST = (req: Request, path: string, body?: any) =>\n  proxyRequest(req, path, {\n    method: \"POST\",\n    body: body instanceof Uint8Array || typeof body === \"string\"\n      ? (body as any)\n      : body != null\n      ? JSON.stringify(body)\n      : undefined,\n    headers: body != null ? { \"content-type\": \"application/json\" } : undefined,\n  });\n\nexport const proxyPATCH = (req: Request, path: string, body?: any) =>\n  proxyPOST(req, path, body && { ...body, __method: \"PATCH\" }); // ou direct PATCH si ton API l’accepte\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/giorn/Desktop/Projet/Medina/Micro_entreprise/Mockfront/ME-main/app/api/partenaires/%5Bid%5D/interactions/route.ts"],"sourcesContent":["import { proxyRequest } from \"../../../_lib/proxy\";\r\n\r\nexport const GET  = (req: Request, { params }: { params: { id: string } }) =>\r\n  // conserve ?limit=&type=\r\n  proxyRequest(req, `/api/partenaires/${params.id}/interactions`);\r\n\r\nexport const POST = (req: Request, { params }: { params: { id: string } }) =>\r\n  proxyRequest(req, `/api/partenaires/${params.id}/interactions`);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,MAAO,CAAC,KAAc,EAAE,MAAM,EAA8B,GACvE,yBAAyB;IACzB,CAAA,GAAA,6HAAA,CAAA,eAAY,AAAD,EAAE,KAAK,CAAC,iBAAiB,EAAE,OAAO,EAAE,CAAC,aAAa,CAAC;AAEzD,MAAM,OAAO,CAAC,KAAc,EAAE,MAAM,EAA8B,GACvE,CAAA,GAAA,6HAAA,CAAA,eAAY,AAAD,EAAE,KAAK,CAAC,iBAAiB,EAAE,OAAO,EAAE,CAAC,aAAa,CAAC","debugId":null}}]
}